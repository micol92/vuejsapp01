{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport Vue from 'vue';\nexport default Vue.extend({\n  name: 'mouse',\n  methods: {\n    getDefaultMouseEventHandlers(suffix, getData, eventFirst = false) {\n      const listeners = Object.keys(this.$listeners).filter(key => key.endsWith(suffix)).reduce((acc, key) => {\n        acc[key] = {\n          event: key.slice(0, -suffix.length)\n        };\n        return acc;\n      }, {});\n      return this.getMouseEventHandlers({\n        ...listeners,\n        ['contextmenu' + suffix]: {\n          event: 'contextmenu',\n          prevent: true,\n          result: false\n        }\n      }, getData, eventFirst);\n    },\n    getMouseEventHandlers(events, getData, eventFirst = false) {\n      const on = {};\n      for (const event in events) {\n        const eventOptions = events[event];\n        if (!this.$listeners[event]) continue; // TODO somehow pull in modifiers\n\n        const prefix = eventOptions.passive ? '&' : (eventOptions.once ? '~' : '') + (eventOptions.capture ? '!' : '');\n        const key = prefix + eventOptions.event;\n        const handler = e => {\n          var _a, _b;\n          const mouseEvent = e;\n          if (eventOptions.button === undefined || mouseEvent.buttons > 0 && mouseEvent.button === eventOptions.button) {\n            if (eventOptions.prevent) {\n              e.preventDefault();\n            }\n            if (eventOptions.stop) {\n              e.stopPropagation();\n            } // Due to TouchEvent target always returns the element that is first placed\n            // Even if touch point has since moved outside the interactive area of that element\n            // Ref: https://developer.mozilla.org/en-US/docs/Web/API/Touch/target\n            // This block of code aims to make sure touchEvent is always dispatched from the element that is being pointed at\n\n            if (e && 'touches' in e) {\n              const classSeparator = ' ';\n              const eventTargetClasses = (_a = e.currentTarget) === null || _a === void 0 ? void 0 : _a.className.split(classSeparator);\n              const currentTargets = document.elementsFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY); // Get \"the same kind\" current hovering target by checking\n              // If element has the same class of initial touch start element (which has touch event listener registered)\n\n              const currentTarget = currentTargets.find(t => t.className.split(classSeparator).some(c => eventTargetClasses.includes(c)));\n              if (currentTarget && !((_b = e.target) === null || _b === void 0 ? void 0 : _b.isSameNode(currentTarget))) {\n                currentTarget.dispatchEvent(new TouchEvent(e.type, {\n                  changedTouches: e.changedTouches,\n                  targetTouches: e.targetTouches,\n                  touches: e.touches\n                }));\n                return;\n              }\n            } // TODO: VCalendar emits the calendar event as the first argument,\n            // but it really should be the native event instead so modifiers can be used\n\n            if (eventFirst) {\n              this.$emit(event, e, getData(e));\n            } else {\n              this.$emit(event, getData(e), e);\n            }\n          }\n          return eventOptions.result;\n        };\n        if (key in on) {\n          /* istanbul ignore next */\n          if (Array.isArray(on[key])) {\n            on[key].push(handler);\n          } else {\n            on[key] = [on[key], handler];\n          }\n        } else {\n          on[key] = handler;\n        }\n      }\n      return on;\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}